// Copyright (c) 2018-2021 The OduwaCoin Developers
// Copyright (c) 2014-2018 The BlackCoin Developers
// Copyright (c) 2011-2013 The PPCoin developers
// Distributed under the MIT software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.

// Stake cache by Qtum
// Copyright (c) 2016-2018 The Qtum developers

#include "pos.h"

#include "chain.h"
#include "chainparams.h"
#include "clientversion.h"
#include "coins.h"
#include "hash.h"
#include "main.h"
#include "uint256.h"
#include "primitives/transaction.h"
#include <stdio.h>
#include "util.h"
#include "bignum.h"

// Protocol switch time of v0.5 kernel protocol
unsigned int nProtocolV05SwitchTime = 1620975600;  // Friday, 14 May 2021 07:00:00 AM (GMT)

// Whether the given transaction is subject to new v0.5 protocol
bool IsProtocolV05(unsigned int nTimeTx)
{
	return (nTimeTx >= nProtocolV05SwitchTime);
}

// Get time weight
int64_t GetWeight(int64_t nIntervalBeginning, int64_t nIntervalEnd)
{
	// Kernel hash weight starts from 0 at the min age
	// this change increases active coins participating the hash and helps
	// to secure the network when proof-of-stake difficulty is low
	unsigned int nStakeMaxAge = -1; // unlimited
	return min(nIntervalEnd - nIntervalBeginning - Params().GetConsensus().nStakeMinAge, (int64_t)nStakeMaxAge);
}

// Get selection interval section (in seconds)
static int64_t GetStakeModifierSelectionIntervalSection(int nSection)
{
	assert(nSection >= 0 && nSection < 64);
	return ((10 * 60) * 63 / (63 + ((63 - nSection) * (MODIFIER_INTERVAL_RATIO - 1))));
}

// Get stake modifier selection interval (in seconds)
static int64_t GetStakeModifierSelectionInterval()
{
	int64_t nSelectionInterval = 0;
	for (int nSection = 0; nSection < 64; nSection++)
		nSelectionInterval += GetStakeModifierSelectionIntervalSection(nSection);
	return nSelectionInterval;
}

static bool GetLastStakeModifier(const CBlockIndex* pindex, uint64_t& nStakeModifier, int64_t& nModifierTime)
{
	if (!pindex)
		return error("GetLastStakeModifier: null pindex");
	while (pindex && pindex->pprev && !pindex->GeneratedStakeModifier())
		pindex = pindex->pprev;
	if (!pindex->GeneratedStakeModifier())
	{
		return error("GetLastStakeModifier: no generation at genesis block");
	}
	nStakeModifier = pindex->nStakeModifier;
	nModifierTime = pindex->GetBlockTime();
	return true;
}

static bool SelectBlockFromCandidates(vector<pair<int64_t, uint256> >& vSortedByTimestamp, map<uint256, const CBlockIndex*>& mapSelectedBlocks,
	int64_t nSelectionIntervalStop, uint64_t nStakeModifierPrev, const CBlockIndex** pindexSelected)
{
	bool fSelected = false;
	arith_uint256 hashBest = 0;
	*pindexSelected = (const CBlockIndex*)0;
	//for (const auto& item : vSortedByTimestamp)
	BOOST_FOREACH(const PAIRTYPE(int64_t, uint256)& item, vSortedByTimestamp)
	{
		if (!mapBlockIndex.count(item.second))
			return error("SelectBlockFromCandidates: failed to find block index for candidate block %s", item.second.ToString().c_str());
		const CBlockIndex* pindex = mapBlockIndex[item.second];
		if (fSelected && pindex->GetBlockTime() > nSelectionIntervalStop)
			break;
		if (mapSelectedBlocks.count(pindex->GetBlockHash()) > 0)
			continue;
		// compute the selection hash by hashing its proof-hash and the
		// previous proof-of-stake modifier
		CHashWriter ss(SER_GETHASH, 0);
		ss << pindex->hashProof << nStakeModifierPrev;
		arith_uint256 hashSelection = UintToArith256(ss.GetHash());
		//CDataStream ss(SER_GETHASH, 0);
		//ss << pindex->hashProof << nStakeModifierPrev;
		//arith_uint256 hashSelection = UintToArith256(Hash(ss.begin(), ss.end()));
		// the selection hash is divided by 2**32 so that proof-of-stake block
		// is always favored over proof-of-work block. this is to preserve
		// the energy efficiency property
		if (pindex->IsProofOfStake())
			hashSelection >>= 32;
		if (fSelected && hashSelection < hashBest)
		{
			hashBest = hashSelection;
			*pindexSelected = (const CBlockIndex*)pindex;
		}
		else if (!fSelected)
		{
			fSelected = true;
			hashBest = hashSelection;
			*pindexSelected = (const CBlockIndex*)pindex;
		}
	}
	return fSelected;
}


// Stake Modifier (hash modifier of proof-of-stake):
// The purpose of stake modifier is to prevent a txout (coin) owner from
// computing future proof-of-stake generated by this txout at the time
// of transaction confirmation. To meet kernel protocol, the txout
// must hash with a future stake modifier to generate the proof.
bool ComputeNextStakeModifier(const CBlockIndex* pindexPrev, uint64_t& nStakeModifier, bool& fGeneratedStakeModifier)
{
	nStakeModifier = 0;
	fGeneratedStakeModifier = false;
	if (!pindexPrev)
	{
		fGeneratedStakeModifier = true;
		return true;  // genesis block's modifier is 0
	}
	// First find current stake modifier and its generation block time
	// if it's not old enough, return the same stake modifier
	int64_t nModifierTime = 0;
	if (!GetLastStakeModifier(pindexPrev, nStakeModifier, nModifierTime))
		return error("ComputeNextStakeModifier: unable to get last modifier");
	if (fDebug)
	{
		LogPrintf("ComputeNextStakeModifier: prev modifier=0x%016x time=%s\n", nStakeModifier, DateTimeStrFormat("%Y-%m-%d %H:%M:%S", nModifierTime));
	}
	if (nModifierTime / nModifierInterval >= pindexPrev->GetBlockTime() / nModifierInterval)
		return true;

	// Sort candidate blocks by timestamp
	vector<pair<int64_t, uint256> > vSortedByTimestamp;
	vSortedByTimestamp.reserve(64 * nModifierInterval / Params().GetConsensus().GetTargetSpacing(pindexPrev->nHeight + 1));
	int64_t nSelectionInterval = GetStakeModifierSelectionInterval();
	int64_t nSelectionIntervalStart = (pindexPrev->GetBlockTime() / nModifierInterval) * nModifierInterval - nSelectionInterval;
	const CBlockIndex* pindex = pindexPrev;
	while (pindex && pindex->GetBlockTime() >= nSelectionIntervalStart)
	{
		vSortedByTimestamp.push_back(make_pair(pindex->GetBlockTime(), pindex->GetBlockHash()));
		pindex = pindex->pprev;
	}
	int nHeightFirstCandidate = pindex ? (pindex->nHeight + 1) : 0;
	//reverse(vSortedByTimestamp.begin(), vSortedByTimestamp.end());
	//sort(vSortedByTimestamp.begin(), vSortedByTimestamp.end());
	// Shuffle before sort
	for (int i = vSortedByTimestamp.size() - 1; i > 1; --i)
		std::swap(vSortedByTimestamp[i], vSortedByTimestamp[GetRand(i)]);
	sort(vSortedByTimestamp.begin(), vSortedByTimestamp.end(), [](const pair<int64_t, uint256> &a, const pair<int64_t, uint256> &b)
	{
		if (a.first != b.first)
			return a.first < b.first;
		// Timestamp equals - compare block hashes
		const uint32_t *pa = a.second.GetDataPtr();
		const uint32_t *pb = b.second.GetDataPtr();
		int cnt = 256 / 32;
		do {
			--cnt;
			if (pa[cnt] != pb[cnt])
				return pa[cnt] < pb[cnt];
		} while (cnt);
		return false; // Elements are equal
	});

	// Select 64 blocks from candidate blocks to generate stake modifier
	uint64_t nStakeModifierNew = 0;
	int64_t nSelectionIntervalStop = nSelectionIntervalStart;
	map<uint256, const CBlockIndex*> mapSelectedBlocks;
	for (int nRound = 0; nRound < min(64, (int)vSortedByTimestamp.size()); nRound++)
	{
		// add an interval section to the current selection round
		nSelectionIntervalStop += GetStakeModifierSelectionIntervalSection(nRound);
		// select a block from the candidates of current round
		if (!SelectBlockFromCandidates(vSortedByTimestamp, mapSelectedBlocks, nSelectionIntervalStop, nStakeModifier, &pindex))
			return error("ComputeNextStakeModifier: unable to select block at round %d", nRound);
		// write the entropy bit of the selected block
		nStakeModifierNew |= (pindex->GetStakeEntropyBit() == 0 ? 0 : uint64_t(1)) << nRound;
		// add the selected block from candidates to selected list
		mapSelectedBlocks.insert(make_pair(pindex->GetBlockHash(), pindex));
		if (fDebug)
			LogPrintf("ComputeNextStakeModifier: selected round %d stop=%s height=%d bit=%d Modifier = 0x%016x\n", nRound, DateTimeStrFormat("%Y-%m-%d %H:%M:%S", nSelectionIntervalStop), pindex->nHeight, pindex->GetStakeEntropyBit(), nStakeModifierNew);
	}

	nStakeModifier = nStakeModifierNew;
	fGeneratedStakeModifier = true;
	return true;
}

// Check whether the coinstake timestamp meets protocol
bool CheckCoinStakeTimestamp(int64_t nTimeBlock, int64_t nTimeTx)
{
	const Consensus::Params& params = Params().GetConsensus();
	//if (params.IsProtocolV2(nTimeBlock))
	//    return (nTimeBlock == nTimeTx) && ((nTimeTx & params.nStakeTimestampMask) == 0);
	//else
	return (nTimeBlock == nTimeTx);
}

// Simplified version of CheckCoinStakeTimestamp() to check header-only timestamp
bool CheckStakeBlockTimestamp(int64_t nTimeBlock)
{
	return CheckCoinStakeTimestamp(nTimeBlock, nTimeBlock);
}

static bool GetKernelStakeModifierV03(CBlockIndex* pindexPrev, uint256 hashBlockFrom, uint64_t& nStakeModifier, int& nStakeModifierHeight, int64_t& nStakeModifierTime, bool fPrintProofOfStake)
{
	const Consensus::Params& params = Params().GetConsensus();
	nStakeModifier = 0;
	if (!mapBlockIndex.count(hashBlockFrom))
		return error("GetKernelStakeModifier() : block not indexed");
	const CBlockIndex* pindexFrom = mapBlockIndex[hashBlockFrom];
	nStakeModifierHeight = pindexFrom->nHeight;
	nStakeModifierTime = pindexFrom->GetBlockTime();
	int64_t nStakeModifierSelectionInterval = GetStakeModifierSelectionInterval();


	// we need to iterate index forward but we cannot depend on chainActive.Next()
	// because there is no guarantee that we are checking blocks in active chain.
	// So, we construct a temporary chain that we will iterate over.
	// pindexFrom - this block contains coins that are used to generate PoS
	// pindexPrev - this is a block that is previous to PoS block that we are checking, you can think of it as tip of our chain
	std::vector<CBlockIndex*> tmpChain;
	int32_t nDepth = pindexPrev->nHeight - (pindexFrom->nHeight - 1); // -1 is used to also include pindexFrom
	tmpChain.reserve(nDepth);
	CBlockIndex* it = pindexPrev;
	for (int i = 1; i <= nDepth && !chainActive.Contains(it); i++) {
		tmpChain.push_back(it);
		it = it->pprev;
	}
	std::reverse(tmpChain.begin(), tmpChain.end());
	size_t n = 0;

	const CBlockIndex* pindex = pindexFrom;
	// loop to find the stake modifier later by a selection interval
	while (nStakeModifierTime < pindexFrom->GetBlockTime() + nStakeModifierSelectionInterval)
	{
		const CBlockIndex* old_pindex = pindex;
		pindex = (!tmpChain.empty() && pindex->nHeight >= tmpChain[0]->nHeight - 1) ? tmpChain[n++] : chainActive.Next(pindex);
		if (n > tmpChain.size() || pindex == NULL) // check if tmpChain[n+1] exists
		{   // reached best block; may happen if node is behind on block chain
			if (fPrintProofOfStake || (old_pindex->GetBlockTime() + params.nStakeMinAge - nStakeModifierSelectionInterval > GetAdjustedTime()))
				return error("GetKernelStakeModifier() : reached best block %s at height %d from block %s",
					old_pindex->GetBlockHash().ToString().c_str(), old_pindex->nHeight, hashBlockFrom.ToString().c_str());
			else
				return false;
		}
		if (pindex->GeneratedStakeModifier())
		{
			nStakeModifierHeight = pindex->nHeight;
			nStakeModifierTime = pindex->GetBlockTime();
		}
	}
	nStakeModifier = pindex->nStakeModifier;
	return true;
}

static bool GetKernelStakeModifierV05(CBlockIndex* pindexPrev, unsigned int nTimeTx, uint64_t& nStakeModifier, int& nStakeModifierHeight, int64_t& nStakeModifierTime, bool fPrintProofOfStake)
{
	const Consensus::Params& params = Params().GetConsensus();
	const CBlockIndex* pindex = pindexPrev;
	nStakeModifierHeight = pindex->nHeight;
	nStakeModifierTime = pindex->GetBlockTime();
	int64_t nStakeModifierSelectionInterval = GetStakeModifierSelectionInterval();

	if (nStakeModifierTime + params.nStakeMinAge - nStakeModifierSelectionInterval <= (int64_t)nTimeTx)
	{
		// Best block is still more than
		// (nStakeMinAge minus a selection interval) older than kernel timestamp
		if (fPrintProofOfStake)
			return error("GetKernelStakeModifier() : best block %s at height %d too old for stake",
				pindex->GetBlockHash().ToString(), pindex->nHeight);
		else
			return false;
	}
	// loop to find the stake modifier earlier by 
	// (nStakeMinAge minus a selection interval)
	while (nStakeModifierTime + params.nStakeMinAge - nStakeModifierSelectionInterval > (int64_t)nTimeTx)
	{
		if (!pindex->pprev)
		{   // reached genesis block; should not happen
			return error("GetKernelStakeModifier() : reached genesis block");
		}
		pindex = pindex->pprev;
		if (pindex->GeneratedStakeModifier())
		{
			nStakeModifierHeight = pindex->nHeight;
			nStakeModifierTime = pindex->GetBlockTime();
		}
	}
	nStakeModifier = pindex->nStakeModifier;
	return true;
}


static bool GetKernelStakeModifier(CBlockIndex* pindexPrev, uint256 hashBlockFrom, unsigned int nTimeTx, uint64_t& nStakeModifier, int& nStakeModifierHeight, int64_t& nStakeModifierTime, bool fPrintProofOfStake)
{
	if (IsProtocolV05(nTimeTx))
		return GetKernelStakeModifierV05(pindexPrev, nTimeTx, nStakeModifier, nStakeModifierHeight, nStakeModifierTime, fPrintProofOfStake);
	else
		return GetKernelStakeModifierV03(pindexPrev, hashBlockFrom, nStakeModifier, nStakeModifierHeight, nStakeModifierTime, true);

}

// OduwaCoin kernel protocol v3
// coinstake must meet hash target according to the protocol:
// kernel (input 0) must meet the formula
//     hash(nStakeModifier + txPrev.nTime + txPrev.vout.hash + txPrev.vout.n + nTime) < bnTarget * nWeight
// this ensures that the chance of getting a coinstake is proportional to the
// amount of coins one owns.
// The reason this hash is chosen is the following:
//   nStakeModifier: scrambles computation to make it very difficult to precompute
//                   future proof-of-stake
//   txPrev.nTime: slightly scrambles computation
//   txPrev.vout.hash: hash of txPrev, to reduce the chance of nodes
//                     generating coinstake at the same time
//   txPrev.vout.n: output number of txPrev, to reduce the chance of nodes
//                  generating coinstake at the same time
//   nTime: current timestamp
//   block/tx hash should not be used here as they can be generated in vast
//   quantities so as to generate blocks faster, degrading the system back into
//   a proof-of-work situation.
//
bool CheckStakeKernelHash(CBlockIndex* pindexPrev, unsigned int nBits, const CCoins* txPrev, const COutPoint& prevout, unsigned int nTimeTx, uint256& hashProofOfStake, bool fPrintProofOfStake)
{
	if (nTimeTx < txPrev->nTime)  // Transaction timestamp violation
		return error("CheckStakeKernelHash() : nTime violation");

	// Base target
	CBigNum bnTarget;
	bnTarget.SetCompact(nBits);

	// Weighted target
	int64_t nValueIn = txPrev->vout[prevout.n].nValue;
	if (nValueIn == 0)
		return error("CheckStakeKernelHash() : nValueIn = 0");
	CBigNum bnWeight = CBigNum(nValueIn) * GetWeight((int64_t)txPrev->nTime, (int64_t)nTimeTx) / COIN / (24 * 60 * 60);

	// Calculate hash
	CDataStream ss(SER_GETHASH, 0);
	CBlockIndex* blockFrom = chainActive[txPrev->nHeight];
	if (blockFrom == NULL) {
		return error("CheckStakeKernelHash() : blockFrom not found");
	}
	uint256 hashBlockFrom = blockFrom->GetBlockHash();
	uint64_t nStakeModifier = 0;
	int nStakeModifierHeight = 0;
	int64_t nStakeModifierTime = 0;
	unsigned int nTimeBlockFrom = blockFrom->GetBlockTime();
	unsigned int nTxPrevOffset = 0;

	// Get transaction index for the previous transaction
	CDiskTxPos postx;
	if (!pblocktree->ReadTxIndex(prevout.hash, postx))
		return error("CheckProofOfStake() : tx index not found");  // tx index not found

	nTxPrevOffset = postx.nTxOffset + 80;

	if (!GetKernelStakeModifier(pindexPrev, hashBlockFrom, nTimeTx, nStakeModifier, nStakeModifierHeight, nStakeModifierTime, true)) {
		return false;
	}
	ss << nStakeModifier;

	ss << (IsProtocolV05(nTimeTx) ? txPrev->nTime : nTimeBlockFrom) << nTxPrevOffset << txPrev->nTime << prevout.n << nTimeTx;

	hashProofOfStake = Hash(ss.begin(), ss.end());

	if (fPrintProofOfStake)
	{
		LogPrintf("CheckStakeKernelHash() : nStakeModifier=0x%016x, txPrev.nTime=%u, txPrev.vout.hash=%s, txPrev.vout.n=%u, nTime=%u, hashProof=%s\n",
			nStakeModifier,
			txPrev->nTime, prevout.hash.ToString(), prevout.n, nTimeTx,
			hashProofOfStake.ToString());
	}

	// Now check if proof-of-stake hash meets target protocol
	if (CBigNum(hashProofOfStake) > bnTarget * bnWeight)
		return false;

	if (fDebug && !fPrintProofOfStake)
	{
		LogPrintf("CheckStakeKernelHash() : nStakeModifier=0x%016x, txPrev.nTime=%u, txPrev.vout.hash=%s, txPrev.vout.n=%u, nTime=%u, hashProof=%s\n",
			nStakeModifier,
			txPrev->nTime, prevout.hash.ToString(), prevout.n, nTimeTx,
			hashProofOfStake.ToString());
	}

	return true;
}

// Check kernel hash target and coinstake signature
bool CheckProofOfStake(CBlockIndex* pindexPrev, const CTransaction& tx, unsigned int nBits, CValidationState &state)
{
	if (!tx.IsCoinStake())
		return error("CheckProofOfStake() : called on non-coinstake %s", tx.GetHash().ToString());

	// Kernel (input 0) must match the stake hash target per coin age (nBits)
	const CTxIn& txin = tx.vin[0];

	// First try finding the previous transaction in database
	CTransaction txPrev;
	uint256 hashBlock = uint256();
	if (!GetTransaction(txin.prevout.hash, txPrev, Params().GetConsensus(), hashBlock, true))
		return state.DoS(100, error("CheckProofOfStake() : INFO: read txPrev failed"));  // previous transaction not in main chain, may occur during initial download

	if (mapBlockIndex.count(hashBlock) == 0)
		return fDebug ? state.DoS(100, error("CheckProofOfStake() : read block failed")) : false; // unable to read block of previous transaction

																								  // Verify inputs
	if (txin.prevout.hash != txPrev.GetHash())
		return state.DoS(100, error("CheckProofOfStake() : coinstake input does not match previous output %s", txin.prevout.hash.GetHex()));

	// Verify signature
	if (!VerifySignature(txPrev, tx, 0, SCRIPT_VERIFY_NONE, 0))
		return state.DoS(100, error("CheckProofOfStake() : VerifySignature failed on coinstake %s", tx.GetHash().ToString()));

	// Min age requirement
	if (pindexPrev->nHeight + 1 - mapBlockIndex[hashBlock]->nHeight < Params().GetConsensus().nCoinbaseMaturity) {
		return state.DoS(100, error("CheckProofOfStake() : stake prevout is not mature, expecting %i and only matured to %i", Params().GetConsensus().nCoinbaseMaturity, pindexPrev->nHeight + 1 - mapBlockIndex[hashBlock]->nHeight));
	}

	return true;
}

bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, unsigned int flags, int nHashType)
{
	assert(nIn < txTo.vin.size());
	const CTxIn& txin = txTo.vin[nIn];
	if (txin.prevout.n >= txFrom.vout.size())
		return false;
	const CTxOut& txout = txFrom.vout[txin.prevout.n];

	if (txin.prevout.hash != txFrom.GetHash())
		return false;

	return VerifyScript(txin.scriptSig, txout.scriptPubKey, flags, TransactionSignatureChecker(&txTo, nIn, 0), NULL);
}

bool CheckKernel(CBlockIndex* pindexPrev, unsigned int nBits, uint32_t nTimeBlock, const COutPoint& prevout) {
	std::map<COutPoint, CStakeCache> tmp;
	return CheckKernel(pindexPrev, nBits, nTimeBlock, prevout, tmp);
}

bool CheckKernel(CBlockIndex* pindexPrev, unsigned int nBits, uint32_t nTime, const COutPoint& prevout, const std::map<COutPoint, CStakeCache>& cache)
{
	uint256 hashProofOfStake;
	CTransaction txPrev;
	uint256 hashBlock = uint256();
	if (!GetTransaction(prevout.hash, txPrev, Params().GetConsensus(), hashBlock, true)) {
		LogPrintf("CheckKernel() : could not find previous transaction %s\n", prevout.hash.ToString());
		return false;
	}

	if (mapBlockIndex.count(hashBlock) == 0) {
		LogPrintf("CheckKernel() : could not find block of previous transaction %s\n", hashBlock.ToString());
		return false;
	}

	if (pindexPrev->nHeight + 1 - mapBlockIndex[hashBlock]->nHeight < Params().GetConsensus().nCoinbaseMaturity) {
		LogPrintf("CheckKernel() : stake prevout is not mature in block %s\n", hashBlock.ToString());
		return false;
	}

	//CheckStakeKernalHash needs a pointer to coins in order to be used to validate the chain on disk/memort
	//Using a pointer in this context is not needed, but is required by the function. 
	//Must ensure coins is deleted to prevent memory leak. 
	if (!IsProtocolV05(nTime)) {
		pindexPrev = mapBlockIndex[hashBlock];
	}

	CCoins* coins = new CCoins(txPrev, pindexPrev->nHeight);
	bool result = CheckStakeKernelHash(pindexPrev, nBits, coins, prevout, nTime, hashProofOfStake);
	delete coins;

	return result;
}

int64_t GetCoinAgeWeight(int64_t nIntervalBeginning, int64_t nIntervalEnd)
{
	return min(nIntervalEnd - nIntervalBeginning - Params().GetConsensus().nStakeMinAge, (int64_t)-1);
}

// PoSV: total coin age spent in transaction, in the unit of coin-days.
// Only those coins meeting minimum age requirement counts. As those
// transactions not in main chain are not currently indexed so we
// might not find out about their coin age. Older transactions are
// guaranteed to be in main chain by sync-checkpoint. This rule is
// introduced to help nodes establish a consistent view of the coin
// age (trust score) of competing branches.
uint64_t GetCoinAge(const CTransaction& tx)
{
	CBigNum bnCentSecond = 0; // coin age in the unit of cent-seconds
	uint64_t nCoinAge = 0;

	if (tx.IsCoinBase())
		return 0;
	const Consensus::Params& params = Params().GetConsensus();

	BOOST_FOREACH(const CTxIn& txin, tx.vin) {
		// First try finding the previous transaction in database
		CTransaction txPrevious;
		uint256 hashTxPrev = txin.prevout.hash;
		uint256 hashBlock;
		if (!GetTransaction(hashTxPrev, txPrevious, params, hashBlock, true))
			continue; // previous transaction not in main chain
		CMutableTransaction txPrev(txPrevious);
		// Read block header
		CBlock block;
		if (!mapBlockIndex.count(hashBlock))
			return 0; // unable to read block of previous transaction
		if (!ReadBlockFromDisk(block, mapBlockIndex[hashBlock], params))
			return 0; // unable to read block of previous transaction
		if (block.nTime + params.nStakeMinAge > tx.nTime)
			continue; // only count coins meeting min age requirement

					  // deal with missing timestamps in PoW blocks
		if (txPrev.nTime == 0)
			txPrev.nTime = block.nTime;

		if (tx.nTime < txPrev.nTime)
			return 0; // Transaction timestamp violation

		int64_t nValueIn = txPrev.vout[txin.prevout.n].nValue;
		int64_t nTimeWeight = GetCoinAgeWeight(txPrev.nTime, tx.nTime);
		bnCentSecond += CBigNum(nValueIn) * (tx.nTime - txPrev.nTime) / CENT;

		if (fDebug && GetBoolArg("-printcoinage", false))
			LogPrintf("coin age nValueIn=%s nTime=%d, txPrev.nTime=%d, nTimeWeight=%s bnCentSecond=%s\n",
				nValueIn, tx.nTime, txPrev.nTime, nTimeWeight, bnCentSecond.ToString().c_str());
	}

	CBigNum bnCoinDay = bnCentSecond * CENT / COIN / (24 * 60 * 60);
	if (fDebug && GetBoolArg("-printcoinage", false))
		LogPrintf("coin age bnCoinDay=%s\n", bnCoinDay.ToString().c_str());
	nCoinAge = bnCoinDay.getuint64();
	return nCoinAge;
}

// PoSV: total coin age spent in block, in the unit of coin-days.
uint64_t GetCoinAge(const CBlock& block)
{
	uint64_t nCoinAge = 0;

	BOOST_FOREACH(const CTransaction& tx, block.vtx)
		nCoinAge += GetCoinAge(tx);

	if (fDebug && GetBoolArg("-printcoinage", false))
		LogPrintf("block coin age total nCoinDays=%s\n", nCoinAge);
	return nCoinAge;
}
